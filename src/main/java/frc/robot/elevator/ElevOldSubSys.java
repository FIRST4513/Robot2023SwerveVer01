// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.elevator;

import frc.lib.util.*;
import edu.wpi.first.wpilibj2.command.SubsystemBase;

import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;


import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.Servo;
import edu.wpi.first.wpilibj.motorcontrol.Spark;

public class ElevOldSubSys extends SubsystemBase {

private Servo clawServo;
private Servo elevSlideMtr;
private DigitalInput elevLwrLimitSw;
private Spark elevMtr;
private Encoder elevEncoder;

    
private double displayCnt = 2; // used to refresh display on every 5 th. cycle ie) 100ms 10x/sec.  

// Claw Servo Variables
private double clawServoValue = 0;
private double clawOpenRate = -0.01;
private double clawCloseRate = +0.01;

private final double clawServoMin = 0.3;        // Fully Opened
private final double clawServoMax = 0.8;        // Fully Closed

private final double clawServoOpen = 0.3;
private final double clawServoCtr = 0.55;       // Half Closed
private final double clawServoClose = 0.8;      // Fully Closed

// Slider Servo Variables
private double sliderServoValue = 0;
private double sliderLeftRate = -0.005;
private double sliderRightRate = 0.005;

private final double sliderServoMin = 0.0;      // Fully Left
private final double sliderServoMax = 1.0;      // Fully Right

private final double sliderServoLeft = 0.0;
private final double sliderServoCtr = 0.5;      // Centered
private final double sliderServoRight = 1.0;

// Elevator Variables
public double mCurrElevPwr;

public static double KRaiseSpeed, KLowerSpeed, KHoldSpeed;
public static final double KRaiseSpeedDefault = +0.60;
public static final double KRaiseSlowSpeed =    +0.35;
public static final double KHoldSpeedDefault =  +0.15;
public static final double KLowerSlowSpeed =    -0.15;
public static final double KLowerSpeedDefault = -0.30;


public static final double KElevMaxTopPos =             41.0;           // This is the top GO NO FURTHER!
public static final double KLimitElevTopSlowPos =       39.0;		// Start slowing the raise at this position   
public static final double KLimitElevBottomSlowPos =    5.0;     // Start slowing the lower at this position
public static final double ELEV_INCH_ABOVE_GROUND =     2.875;  // Inches the claw is above ground when fully lowered

public static final double ELEV_ENCODER_CONV = 0.03461;      // Inches the elevator rises for each encoder count

public static final boolean KLIMIT_SWITCH_PRESSED = false;  // The state of the magnetic sensor when activated at the bottom

public ElevOldSubSys() {
    clawServo = new Servo(9);
    addChild("clawServo", clawServo);
 
    elevSlideMtr = new Servo(8);
    addChild("ElevSlideMtr", elevSlideMtr);
    
    elevLwrLimitSw = new DigitalInput(0);
    addChild("elevLwrLimitSw", elevLwrLimitSw);

    elevMtr = new Spark(7);
    addChild("ElevMtr",elevMtr);
    elevMtr.setInverted(false);

    elevEncoder = new Encoder(4, 5, false, EncodingType.k4X);
    addChild("elevEncoder",elevEncoder);

    elevEncoder.setDistancePerPulse(1.0);

    KRaiseSpeed  = KRaiseSpeedDefault ;
    KLowerSpeed = KLowerSpeedDefault ;
    KHoldSpeed =  KHoldSpeedDefault ;

    setClawServoToCtrPosition();
    setSliderServoToCtrPosition();

    }

    @Override
    public void periodic() {
        // This method will be called once per scheduler run
        if ( (displayCnt % 10) != 0) {
            // NOT Time yet, only update dashboard every 200 ms
            displayCnt++;
        } else {
            // Its time now !
            displayCnt = 0;
            updateShuffleboard();
        }

        // Update servos to desired position
        clawServo.setPosition(clawServoValue);
        elevSlideMtr.setPosition(sliderServoValue);

        if(isLowerLmtSwPressed()){
            // If Lower limit sw is triggered reset encoders to zero
            elevEncoder.reset();
        }
    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    // --------------------------------------------
    // ------------   Claw Methods   --------------
    // --------------------------------------------
    public void setClawServoToCtrPosition()     { setClawServoToPosition(clawServoCtr); }
    public void setClawServoToOpenPosition()    { setClawServoToPosition(clawServoOpen); }
    public void setClawServoToClosedPosition()  { setClawServoToPosition(clawServoClose); }
    public double getClawServoPosition()        { return clawServoValue; } 

    public void clawOpen(){
        clawServoValue = clawServoValue + clawOpenRate;
        setClawServoToPosition(clawServoValue);
    }

    public void clawClose(){
        clawServoValue = clawServoValue + clawCloseRate;
        setClawServoToPosition(clawServoValue);   
    }

    public void setClawServoToPosition(double value){
        // Valid range 0.0 to 1.0 Extreme Left/Right
        if (value > clawServoMax) {value = clawServoMax;}
        if (value < clawServoMin) {value = clawServoMin;}
        clawServoValue = value;
        clawServo.set(clawServoValue);
    }

    // --------------------------------------------
    // ---------    Slider Methods    -------------
    // --------------------------------------------

    public void setSliderServoToLeftPosition()      { setSliderServoToPosition(sliderServoLeft); }    
    public void setSliderServoToCtrPosition()       { setSliderServoToPosition(sliderServoCtr); }
    public void setSliderServoToRightPosition()     { setSliderServoToPosition(sliderServoRight); }
    public double getSliderServoPosition()          { return sliderServoValue; } 

    public void sliderLeft(){
        sliderServoValue = sliderServoValue + sliderLeftRate;
        setSliderServoToPosition(sliderServoValue);
    }

    public void sliderRight(){
        sliderServoValue = sliderServoValue + sliderRightRate;
        setSliderServoToPosition(sliderServoValue);
    }

    public void setSliderServoToPosition(double value){
        // Valid range 0.0 to 1.0 Extreme Left/Right
        if (value > sliderServoMax) {value = sliderServoMax;}
        if (value < sliderServoMin) {value = sliderServoMin;}
        sliderServoValue = value;
        elevSlideMtr.set(sliderServoValue);
    }

    // --------------------------------------------
    // ---------   Elevator Methods   -------------
    // --------------------------------------------
 
    public void elevLower(boolean overide ) {
    	mCurrElevPwr = KLowerSpeed;
        // Are we at the bottom yet
    	if (isLowerLmtSwPressed()){  		
    		elevStopMtr(); 
    		return;
    	}
    	//  This is for slowing down as we approach the bottom    		
    	if((getElevPosInches()<= KLimitElevBottomSlowPos) && (!overide)) {
    		mCurrElevPwr= KLowerSlowSpeed;
    	}
        // Send Power to motor        
		elevMtr.set(mCurrElevPwr);  	
    }
    
    public void elevRaise( boolean overide ) {
    	mCurrElevPwr = KRaiseSpeed;
        // Are we at the top yet
    	if (isUpperLmtReached()) {
			 elevHoldMtr();
			 return;
    	}
    	//  This is for slowing down as we approach the top
    	if((getElevPosInches()>= KLimitElevTopSlowPos) && (!overide)) {
    		mCurrElevPwr= KRaiseSlowSpeed;
    	}
        // Send Power to motor
		elevMtr.set(mCurrElevPwr);    	
    }

    public void elevStopMtr(){
        mCurrElevPwr = 0;
    	elevMtr.set(-mCurrElevPwr);	
    }

    public void elevHoldMtr(){
    	if (isLowerLmtSwPressed() == true) {
    		mCurrElevPwr = 0;	
    	} else {
        	mCurrElevPwr = KHoldSpeed ;
    	}
    	elevMtr.set(mCurrElevPwr);
    }
        

    // -------------------------------------
    // ---------  Get Sensor  Data ---------
    // -------------------------------------
    public boolean isUpperLmtReached() {
        // Check Encoder for exceeding top value
 	   if (getElevPosInches() >= KElevMaxTopPos)
 		   return true;
 	   else
 		   return false;
    }

    public boolean isUpperLmtNotReached() {
 	   return !isUpperLmtReached();
    }
    
    public boolean isLowerLmtSwPressed() {
 	   if (elevLwrLimitSw.get() == KLIMIT_SWITCH_PRESSED)
 		   return true;
 	   else
 		   return false;
    }
    
    public boolean isLowerLmtSwNotPressed() {
 	   return !isLowerLmtSwPressed();
    }

    public int getElevEncoder() { return elevEncoder.get(); }

    public double getElevPosInches(){
    	double currElevPos = (( (double)elevEncoder.get() * ELEV_ENCODER_CONV) + ELEV_INCH_ABOVE_GROUND) ;    // Converts to Inches
    	currElevPos = Rmath.mRound(currElevPos , 2);		// Round to 1 decimal digits
    	return currElevPos;
    }
       
    // ------------------------------------------------------------------------
    // ------------------------ Smart Dashboard Methods -----------------------
    private void updateShuffleboard() {
        SmartDashboard.putNumber("Elev Enc Cnt",            getElevEncoder());
        SmartDashboard.putNumber("Elev Height",           getElevPosInches());
        if (isUpperLmtReached()){
            SmartDashboard.putString("Elev Position",      "Elev is at TOP");
        }
        else if (isLowerLmtSwPressed()){
            SmartDashboard.putString("Elev Position",      "Elev is at Botom");
        } else {
            SmartDashboard.putString("Elev Position",      "Elev is in Between");
        }
        SmartDashboard.putNumber("Elev Speed",              mCurrElevPwr);

        SmartDashboard.putNumber("Claw Servo Value",        Rmath.mRound(clawServoValue,4));
        SmartDashboard.putNumber("Slider Servo Value",      Rmath.mRound(sliderServoValue,4));
    }
}


